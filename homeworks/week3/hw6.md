## hw1：好多星星
1. 打算自己組字串，不使用內建 repeat()
2. n 的大小為 1<=n<=30
3. 因此 n 的預設值為 1
4. 建立空字串 tempStr 與空陣列 startArray
5. 設定一迴圈，當 i < n 時， i++
6. 並在迴圈內組字串， tempStr += '*'
7. 因為 tempStr 設立在迴圈外，因此會保留每次運算的值
8. 並在每次迴圈組字串完成後，將結果放入陣列中
## hw2：大小寫互換
1. 取得輸入字串總長度，並且建立一個空陣列 tempArray
2. 使用 for 迴圈遍歷整個字串
3. 不使用內建的語法，因此從 ACSII CODE 找出規律
4. 小轉大 -32 ， 大轉小 +32
5. 若非 A~Z 、 a~z 則無視
6. 將每次的結果放入 tempArray
7. 跑完迴圈後將結果 以 join 組合並回傳
## hw3：判斷質數
1. 建立特殊案例，當輸入 n === 1 ，回傳 false
2. 設定一迴圈， i 從 2 開始，因為 1 被排除了，當 i < n ， i++
3. 每次都對 n 取 i 的餘數，如果等餘 0 代表可以整除，只要可以整除就不是質數，回傳 false
4. 跑完迴圈後，代表都不可以整除，則回傳 true
## hw4：判斷迴文
1. 取得輸入字串總長度，因題目給定字串長度小於 100，代表可能 < 1 或為負數
2. 建立特殊案例，若字串長度 <= 0 ，回傳 false
3. 觀察規律可發現，若字串的第 0 個與最末個內容相等，則往下一圈比較，若不相等就回傳 false
4. 推得規律為起始點i ， 最末端為字串長度 -1 -i
6. 設定迴圈終止條件，只要跑完長度的一半就可以判斷了，所以就是長度 / 2
7. 如果迴圈內容相等，則什麼都不做，當迴圈完成時，回傳 true
## hw5：大數加法
1. 假設有兩字串 '123' 與  '4569'
2. 陣列上顯示為 ['1', '2', '3'] 、 ['4', '5', '6', '9']
3. 比較陣列長度，如果 A 陣列 >= B 陣列 ，則以 A 陣列長度為基準，反之亦然
4. 以基準陣列長度扣掉較小陣列長度為基準，在較小的陣列前面補上 0
5. 設置一空陣列 resultArray 與 counter = 0 做為近位計數器
6. 列出直式加法，
   ['0', '1', '2', '3']
   ['4', '5', '6', '9']
7. 設定 for 迴圈， i = 陣列長度-1 ， 當 i => 0 時， i--
8. 當兩陣列元素、計數器相加若 >= 10
   對其數值取 10 的餘數，
   計算總和 + count ，
   設定技術器數值，若相加 <= 10 則設定為 1 ，若大於10 則取 /10 後的整數部份
   並將餘數推入 resultArray 陣列，
   當 i === 0 時代表來到了陣列的第一個元素，但此時仍需要進位，
   因此額外推入一個 counter 值

   若兩陣列元素、計數器相加 < 10
   計算總和 + count
   重設進位計數器 為 0
   將數值推入 resultArray 陣列
9. 將 resultArray 陣列反轉並使用 join 回傳字串